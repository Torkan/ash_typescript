defmodule AshTypescript.Rpc.Codegen do
  @moduledoc """
  Generates TypeScript code for interacting with Ash resources via Rpc.
  """
  import AshTypescript.Codegen
  import AshTypescript.Filter
  import AshTypescript.Helpers

  def generate_typescript_types(otp_app, opts \\ []) do
    endpoint_process = Keyword.get(opts, :run_endpoint, "/rpc/run")
    endpoint_validate = Keyword.get(opts, :validate_endpoint, "/rpc/validate")

    resources_and_actions = get_rpc_resources_and_actions(otp_app)

    generate_full_typescript(
      resources_and_actions,
      endpoint_process,
      endpoint_validate,
      otp_app
    )
  end

  defp get_rpc_resources_and_actions(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(fn domain ->
      # Get Rpc configuration from the domain
      rpc_config = AshTypescript.Rpc.Info.rpc(domain)

      Enum.flat_map(rpc_config, fn %{resource: resource, rpc_actions: rpc_actions} ->
        Enum.map(rpc_actions, fn rpc_action ->
          action = Ash.Resource.Info.action(resource, rpc_action.action)
          {resource, action, rpc_action}
        end)
      end)
    end)
  end

  defp generate_full_typescript(
         rpc_resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app
       ) do
    # Extract only the Rpc resources
    rpc_resources =
      otp_app
      |> Ash.Info.domains()
      |> Enum.flat_map(fn domain ->
        AshTypescript.Rpc.Info.rpc(domain)
        |> Enum.map(fn %{resource: r} -> r end)
      end)

    actions =
      otp_app
      |> Ash.Info.domains()
      |> Enum.flat_map(fn domain ->
        AshTypescript.Rpc.Info.rpc(domain)
        |> Enum.flat_map(fn %{resource: resource, rpc_actions: rpc_actions} ->
          Enum.map(rpc_actions, fn %{action: action} ->
            Ash.Resource.Info.action(resource, action)
          end)
        end)
      end)

    """
    // Generated by AshTypescript
    // Do not edit this file manually

    #{generate_ash_type_aliases(rpc_resources, actions)}

    #{generate_all_schemas_for_resources(rpc_resources, rpc_resources)}

    #{generate_filter_types(rpc_resources, rpc_resources)}

    #{generate_utility_types(rpc_resources)}

    #{generate_rpc_functions(rpc_resources_and_actions, endpoint_process, endpoint_validate, otp_app, rpc_resources)}
    """
  end

  defp generate_utility_types(resources) do
    """
    // Resource-specific Load Input Types
    #{generate_resource_load_input_types(resources)}

    // Load key metadata for each resource
    #{generate_load_key_metadata(resources)}

    // Load Input Type Utilities
    type ExtractLoadInputStrings<LoadInputs> = LoadInputs extends readonly (infer U)[]
      ? U extends string
        ? U
        : never
      : never;

    type ExtractLoadInputObjects<LoadInputs> = LoadInputs extends readonly (infer U)[]
      ? U extends Record<string, any>
        ? U
        : never
      : never;

    // Result inference for resource-specific load inputs
    type InferLoadResult<
      Resource,
      LoadInputs extends readonly any[]
    > =
      // Simple fields (no nested loads)
      Pick<Resource, Extract<ExtractLoadInputStrings<LoadInputs>, keyof Resource>> &
      // Relationship fields (with nested loads)
      InferRelationshipLoads<Resource, ExtractLoadInputObjects<LoadInputs>> &
      // Calculation fields (with nested loads under 'load' key)
      InferNestedLoads<Resource, ExtractLoadInputObjects<LoadInputs>>;

    // Infer relationship loads
    type InferRelationshipLoads<
      Resource,
      LoadObjects extends Record<string, any>
    > = {
      [K in keyof LoadObjects as K extends GetRelationshipLoadKeys<Resource> ? K : never]?:
        K extends keyof Resource
          ? Resource[K] extends (infer Item)[]
            ? LoadObjects[K] extends any[]
              ? Array<InferLoadResult<Item, LoadObjects[K]>>
              : never
            : LoadObjects[K] extends any[]
              ? InferLoadResult<Resource[K], LoadObjects[K]>
              : never
          : never;
    };

    // Infer nested loads (calculations with 'load' key)
    type InferNestedLoads<
      Resource,
      LoadObjects extends Record<string, any>
    > = {
      [K in keyof LoadObjects as K extends GetNestedLoadKeys<Resource> ? K : never]?:
        LoadObjects[K] extends { load?: infer LoadSpec }
          ? LoadSpec extends any[]
            ? GetNestedLoadResultType<Resource, K, LoadSpec> | null
            : never
          : never;
    };

    // Get the correct result type for nested loads based on the calculation
    type GetNestedLoadResultType<Resource, K, LoadSpec extends any[]> =
      Resource extends Todo
        ? K extends "self"
          ? InferLoadResult<Todo, LoadSpec>
          : never
        : Resource extends Comment
          ? never  // Comment has no nested load fields currently
        : Resource extends User
          ? never  // User has no nested load fields currently
        : never;

    // Helper types to get the appropriate keys for each resource
    type GetSimpleLoadKeys<Resource> =
      Resource extends Todo ? TodoSimpleLoadKeys :
      Resource extends Comment ? CommentSimpleLoadKeys :
      Resource extends User ? UserSimpleLoadKeys :
      never;

    type GetRelationshipLoadKeys<Resource> =
      Resource extends Todo ? TodoRelationshipLoadKeys :
      Resource extends Comment ? CommentRelationshipLoadKeys :
      Resource extends User ? UserRelationshipLoadKeys :
      never;

    type GetNestedLoadKeys<Resource> =
      Resource extends Todo ? TodoNestedLoadKeys :
      Resource extends Comment ? CommentNestedLoadKeys :
      Resource extends User ? UserNestedLoadKeys :
      never;


    """
  end

  # Helper functions for resource field analysis
  defp get_loadable_attributes(resource) do
    Ash.Resource.Info.public_attributes(resource)
    |> Enum.map(& &1.name)
  end

  defp get_loadable_relationships(resource, rpc_resources) do
    Ash.Resource.Info.public_relationships(resource)
    |> Enum.filter(fn rel -> rel.destination in rpc_resources end)
    |> Enum.map(fn rel -> {rel.name, rel.destination} end)
  end

  defp get_loadable_calculations(resource) do
    Ash.Resource.Info.public_calculations(resource)
    |> Enum.map(fn calc ->
      {calc.name, calc.type, calc.constraints, calc.arguments}
    end)
  end

  defp get_loadable_aggregates(resource) do
    Ash.Resource.Info.public_aggregates(resource)
    |> Enum.map(& &1.name)
  end

  defp generate_resource_load_input_types(resources) do
    resources
    |> Enum.map(&generate_single_resource_load_input_type(&1, resources))
    |> Enum.join("\n\n")
  end

  defp generate_single_resource_load_input_type(resource, rpc_resources) do
    resource_name = resource |> Module.split() |> List.last()

    attributes = get_loadable_attributes(resource)
    relationships = get_loadable_relationships(resource, rpc_resources)
    calculations = get_loadable_calculations(resource)
    aggregates = get_loadable_aggregates(resource)

    # Separate simple calculations from complex ones
    {simple_calculations, complex_calculations} =
      calculations
      |> Enum.split_with(fn {_name, calc_type, constraints, arguments} ->
        # Simple calculations are those without arguments and not returning loadable structs
        arguments == [] && !is_loadable_struct_calculation(calc_type, constraints, rpc_resources)
      end)

    simple_calc_names = Enum.map(simple_calculations, fn {name, _, _, _} -> name end)

    # Generate attribute literals (including simple calculations)
    attribute_literals =
      (attributes ++ aggregates ++ simple_calc_names)
      |> Enum.map(&"\"#{&1}\"")
      |> Enum.join(" | ")

    # Generate relationship load types
    relationship_types =
      relationships
      |> Enum.map(fn {rel_name, dest_resource} ->
        dest_name = dest_resource |> Module.split() |> List.last()
        "  #{rel_name}?: #{dest_name}LoadInput[];"
      end)
      |> Enum.join("\n")

    # Generate calculation load types (only for complex calculations)
    calculation_types =
      complex_calculations
      |> Enum.map(fn {calc_name, calc_type, constraints, arguments} ->
        generate_calculation_load_type(
          calc_name,
          calc_type,
          constraints,
          arguments,
          rpc_resources
        )
      end)
      |> Enum.join("\n")

    load_object_types =
      [relationship_types, calculation_types]
      |> Enum.reject(&(&1 == ""))
      |> Enum.join("\n")

    """
    type #{resource_name}LoadInput =
      | #{attribute_literals}
      | {
    #{load_object_types}
        };
    """
  end

  defp is_loadable_struct_calculation(calc_type, constraints, rpc_resources) do
    {actual_type, actual_constraints} =
      case calc_type do
        %{type: type, constraints: type_constraints} -> {type, type_constraints}
        %{type: type} -> {type, constraints}
        atom_type -> {atom_type, constraints}
      end

    case actual_type do
      Ash.Type.Struct ->
        instance_of = Keyword.get(actual_constraints || [], :instance_of)
        instance_of && instance_of in rpc_resources

      _ ->
        false
    end
  end

  defp generate_load_key_metadata(resources) do
    resources
    |> Enum.map(&generate_single_resource_load_metadata(&1, resources))
    |> Enum.join("\n\n")
  end

  defp generate_single_resource_load_metadata(resource, rpc_resources) do
    resource_name = resource |> Module.split() |> List.last()

    attributes = get_loadable_attributes(resource)
    relationships = get_loadable_relationships(resource, rpc_resources)
    calculations = get_loadable_calculations(resource)
    aggregates = get_loadable_aggregates(resource)

    # Simple load keys: attributes, aggregates, and simple calculations
    {simple_calculations, complex_calculations} =
      calculations
      |> Enum.split_with(fn {_name, calc_type, constraints, arguments} ->
        arguments == [] && !is_loadable_struct_calculation(calc_type, constraints, rpc_resources)
      end)

    simple_calc_names = Enum.map(simple_calculations, fn {name, _, _, _} -> name end)

    simple_keys =
      (attributes ++ aggregates ++ simple_calc_names)
      |> Enum.map(&"\"#{&1}\"")
      |> Enum.join(" | ")

    # Relationship load keys
    relationship_keys =
      relationships
      |> Enum.map(fn {name, _} -> "\"#{name}\"" end)
      |> Enum.join(" | ")

    # Nested load keys: calculations that return structs with load-through capability
    nested_keys =
      complex_calculations
      |> Enum.filter(fn {_name, calc_type, constraints, _arguments} ->
        is_loadable_struct_calculation(calc_type, constraints, rpc_resources)
      end)
      |> Enum.map(fn {name, _, _, _} -> "\"#{name}\"" end)
      |> Enum.join(" | ")

    simple_type = if simple_keys == "", do: "never", else: simple_keys
    relationship_type = if relationship_keys == "", do: "never", else: relationship_keys
    nested_type = if nested_keys == "", do: "never", else: nested_keys

    """
    type #{resource_name}SimpleLoadKeys = #{simple_type};
    type #{resource_name}RelationshipLoadKeys = #{relationship_type};
    type #{resource_name}NestedLoadKeys = #{nested_type};
    """
  end

  defp generate_calculation_load_type(calc_name, calc_type, constraints, arguments, rpc_resources) do
    # Handle both atom format (:struct) and map format (%{type: :struct})
    {actual_type, actual_constraints} =
      case calc_type do
        %{type: type, constraints: type_constraints} -> {type, type_constraints}
        %{type: type} -> {type, constraints}
        atom_type -> {atom_type, constraints}
      end

    case actual_type do
      Ash.Type.Struct ->
        # Check if it's an instance_of constraint (loadable struct)
        instance_of = Keyword.get(actual_constraints || [], :instance_of)

        if instance_of && instance_of in rpc_resources do
          dest_name = instance_of |> Module.split() |> List.last()

          if arguments != [] do
            "  #{calc_name}?: { input?: #{generate_calc_input_type(arguments)}, load?: #{dest_name}LoadInput[] };"
          else
            "  #{calc_name}?: { load?: #{dest_name}LoadInput[] };"
          end
        else
          if arguments != [] do
            "  #{calc_name}?: { input?: #{generate_calc_input_type(arguments)} };"
          else
            "  #{calc_name}?: boolean;"
          end
        end

      _ ->
        if arguments != [] do
          "  #{calc_name}?: { input?: #{generate_calc_input_type(arguments)} };"
        else
          "  #{calc_name}?: boolean;"
        end
    end
  end

  defp generate_calc_input_type(arguments) do
    if arguments == [] do
      "Record<string, any>"
    else
      arg_types =
        arguments
        |> Enum.map(fn arg ->
          optional = arg.allow_nil? || arg.default != nil
          "#{arg.name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)}"
        end)
        |> Enum.join(", ")

      "{ #{arg_types} }"
    end
  end

  defp generate_rpc_functions(
         resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app,
         _resources
       ) do
    # Generate functions for each Rpc action
    rpc_functions =
      resources_and_actions
      |> Enum.map(
        &generate_rpc_function(
          &1,
          resources_and_actions,
          endpoint_process,
          endpoint_validate,
          otp_app
        )
      )
      |> Enum.join("\n\n")

    rpc_functions
  end

  defp generate_rpc_function(
         {resource, action, rpc_action},
         _resources_and_actions,
         endpoint_process,
         endpoint_validate,
         _otp_app
       ) do
    # Convert Rpc action name to camelCase function name (e.g., read_todo -> readTodos)
    rpc_action_name = to_string(rpc_action.name)

    # Generate config type
    config_type = generate_config_type(resource, action, rpc_action_name)

    # Generate result inference type
    result_type = generate_result_type(resource, action, rpc_action_name)

    # Generate payload builder
    payload_builder = generate_payload_builder(rpc_action, action, rpc_action_name)

    # Generate Rpc function
    rpc_function =
      generate_rpc_execution_function(rpc_action, action, rpc_action_name, endpoint_process)

    # Generate validation function (for create, update, destroy actions only)
    validation_function =
      generate_validation_function(rpc_action, action, rpc_action_name, endpoint_validate)

    functions_section =
      if validation_function == "" do
        rpc_function
      else
        """
        #{rpc_function}

        #{validation_function}
        """
      end

    """
    #{config_type}

    #{result_type}

    #{payload_builder}

    #{functions_section}
    """
  end

  defp generate_config_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    _function_name = snake_to_camel_case(rpc_action_name)
    config_name = "#{snake_to_pascal_case(rpc_action_name)}Config"

    # Base config fields
    fields_field = [
      "  fields: readonly #{resource_name}LoadInput[];"
    ]

    # Add input fields based on action type
    input_fields =
      case action.type do
        :read ->
          filters =
            if action.get? do
              []
            else
              [
                "  filter?: #{resource_name}FilterInput;"
              ]
            end

          pagination_and_sort = [
            "  sort?: string;",
            "  page?: {",
            "    limit?: number;",
            "    offset?: number;",
            "  };"
          ]

          filters ++ pagination_and_sort

        :create ->
          accepts = Ash.Resource.Info.action(resource, action.name).accept || []
          arguments = action.arguments

          if accepts != [] || arguments != [] do
            ["  input: {"] ++
              Enum.map(accepts, fn field_name ->
                attr = Ash.Resource.Info.attribute(resource, field_name)
                optional = attr.allow_nil? || attr.default != nil
                base_type = get_ts_type(attr)
                field_type = if attr.allow_nil?, do: "#{base_type} | null", else: base_type

                "    #{field_name}#{if optional, do: "?", else: ""}: #{field_type};"
              end) ++
              Enum.map(arguments, fn arg ->
                optional = arg.allow_nil? || arg.default != nil

                "    #{arg.name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
              end) ++
              ["  };"]
          else
            []
          end

        action_type when action_type in [:update, :destroy] ->
          primary_key_attrs = Ash.Resource.Info.primary_key(resource)

          primary_key_field =
            if Enum.count(primary_key_attrs) == 1 do
              attr_name = Enum.at(primary_key_attrs, 0)
              attr = Ash.Resource.Info.attribute(resource, attr_name)
              ["  primaryKey: #{get_ts_type(attr)};"]
            else
              ["  primaryKey: {"] ++
                Enum.map(primary_key_attrs, fn attr_name ->
                  attr = Ash.Resource.Info.attribute(resource, attr_name)
                  "    #{attr.name}: #{get_ts_type(attr)};"
                end) ++
                ["  };"]
            end

          input_fields =
            if action.accept != [] || action.arguments != [] do
              ["  input: {"] ++
                Enum.map(action.accept, fn field_name ->
                  attr = Ash.Resource.Info.attribute(resource, field_name)

                  if attr.allow_nil? do
                    "    #{field_name}?: #{get_ts_type(attr)} | null;"
                  else
                    "    #{field_name}: #{get_ts_type(attr)};"
                  end
                end) ++
                Enum.map(action.arguments, fn arg ->
                  optional = arg.allow_nil? || arg.default != nil

                  "    #{arg.name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
                end) ++
                ["  };"]
            else
              []
            end

          primary_key_field ++ input_fields

        :action ->
          arguments = action.arguments

          if arguments != [] do
            ["  input: {"] ++
              Enum.map(arguments, fn arg ->
                optional = arg.allow_nil? || arg.default != nil

                "    #{arg.name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
              end) ++
              ["  };"]
          else
            []
          end
      end

    all_fields =
      if action.type in [:read, :create, :update] do
        input_fields ++ fields_field
      else
        input_fields
      end

    """
    export type #{config_name} = {
    #{Enum.join(all_fields, "\n")}
    };
    """
  end

  defp generate_result_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    _function_name = snake_to_camel_case(rpc_action_name)

    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    case action.type do
      :read when action.get? ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          InferLoadResult<#{resource_name}, Config["fields"]> | null;
        """

      :read ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          Array<InferLoadResult<#{resource_name}, Config["fields"]>>;
        """

      action_type when action_type in [:create, :update] ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          InferLoadResult<#{resource_name}, Config["fields"]>;
        """

      :destroy ->
        """
        type Infer#{rpc_action_name_pascal}Result = void;
        """

      action_type when action_type in [:action, :generic] ->
        # For generic actions, use the returns type if specified
        if action.returns do
          return_type = get_ts_type(%{type: action.returns, constraints: action.constraints})

          """
          type Infer#{rpc_action_name_pascal}Result = #{return_type};
          """
        else
          """
          type Infer#{rpc_action_name_pascal}Result = any;
          """
        end
    end
  end

  defp generate_payload_builder(_rpc_action, action, rpc_action_name) do
    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    cond do
      action.type == :read and not action.get? ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            fields: config.fields
          };

          if (config.filter) {
            payload.filter = config.filter;
          } else {
            payload.filter = {};
          }

          if (config.page) {
            payload.page = config.page;
          }

          if (config.sort) {
            payload.sort = config.sort;
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :read and action.get? ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            fields: config.fields
          };

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :create ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            fields: config.fields
          };

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :update ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            fields: config.fields,
            primary_key: config.primaryKey
          };

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :destroy ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {

          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            primary_key: config.primaryKey
          };

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :action ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}"
          };

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """
    end
  end

  defp generate_rpc_execution_function(_rpc_action, action, rpc_action_name, endpoint_process) do
    function_name = snake_to_camel_case(rpc_action_name)

    # Add proper type handling for different action types
    is_generic_action = action.type in [:action, :generic]

    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    result_handling =
      case action.type do
        :destroy ->
          "return;"

        _ when is_generic_action ->
          "return result.data as Infer#{rpc_action_name_pascal}Result;"

        _ ->
          "return result.data as Infer#{rpc_action_name_pascal}Result<T>;"
      end

    function_signature =
      case action.type do
        :destroy ->
          "export async function #{function_name}(\n  config: #{rpc_action_name_pascal}Config\n): Promise<void>"

        _ when is_generic_action ->
          "export async function #{function_name}(\n  config: #{rpc_action_name_pascal}Config\n): Promise<Infer#{rpc_action_name_pascal}Result>"

        _ ->
          "export async function #{function_name}<T extends #{rpc_action_name_pascal}Config>(\n  config: T\n): Promise<Infer#{rpc_action_name_pascal}Result<T>>"
      end

    """
    #{function_signature} {
      const payload = build#{rpc_action_name_pascal}Payload(config);

      const csrfToken = document
        ?.querySelector("meta[name='csrf-token']")
        ?.getAttribute("content");

      const headers: Record<string, string> = {
        "Content-Type": "application/json",
      };

      if (csrfToken) {
        headers["X-CSRF-Token"] = csrfToken;
      }

      const response = await fetch("#{endpoint_process}", {
        method: "POST",
        headers,
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Rpc call failed: ${response.statusText}`);
      }

      const result = await response.json();
      #{result_handling}
    }
    """
  end

  defp generate_validation_function(rpc_action, action, rpc_action_name, endpoint_validate) do
    # Only generate validation functions for create, update, and destroy actions
    case action.type do
      :read ->
        ""

      :action ->
        ""

      _ ->
        # Convert Rpc action name to pascal case for validation function name
        rpc_action_name_pascal = AshTypescript.Helpers.snake_to_pascal_case(rpc_action_name)
        validation_function_name = "validate#{rpc_action_name_pascal}"

        # Determine if we need primary_key parameter
        needs_primary_key = action.type in [:update, :destroy]

        # Check if action has input parameters
        has_input = length(action.accept) > 0 or length(action.arguments) > 0

        # Build function signature
        params =
          case {needs_primary_key, has_input} do
            {true, true} ->
              "primaryKey: string | number, input: #{rpc_action_name_pascal}Config[\"input\"]"

            {true, false} ->
              "primaryKey: string | number"

            {false, true} ->
              "input: #{rpc_action_name_pascal}Config[\"input\"]"

            {false, false} ->
              ""
          end

        # Build payload construction
        base_payload = ["action: \"#{rpc_action.name}\""]

        payload_with_pk =
          if needs_primary_key do
            base_payload ++ ["primary_key: primaryKey"]
          else
            base_payload
          end

        payload_lines =
          if has_input do
            payload_with_pk ++ ["input: input"]
          else
            payload_with_pk ++ ["input: {}"]
          end

        payload_content = Enum.join(payload_lines, ",\n    ")

        """
        export async function #{validation_function_name}(#{params}): Promise<{
          success: boolean;
          errors?: Record<string, string[]>;
        }> {
          const payload = {
            #{payload_content}
          };

          const csrfToken = document
            ?.querySelector("meta[name='csrf-token']")
            ?.getAttribute("content");

          const headers: Record<string, string> = {
            "Content-Type": "application/json",
          };

          if (csrfToken) {
            headers["X-CSRF-Token"] = csrfToken;
          }

          const response = await fetch("#{endpoint_validate}", {
            method: "POST",
            headers,
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error(`Validation call failed: ${response.statusText}`);
          }

          const result = await response.json();

          if (result.success) {
            return { success: true };
          } else {
            return { success: false, errors: result.errors };
          }
        }
        """
    end
  end
end
